{"ast":null,"code":"/*!\n  * Bootstrap config.js v5.2.3 (https://getbootstrap.com/)\n  * Copyright 2011-2022 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n  */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('./index'), require('../dom/manipulator')) : typeof define === 'function' && define.amd ? define(['./index', '../dom/manipulator'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Config = factory(global.Index, global.Manipulator));\n})(this, function (index, Manipulator) {\n  'use strict';\n\n  const _interopDefaultLegacy = e => e && typeof e === 'object' && 'default' in e ? e : {\n    default: e\n  };\n\n  const Manipulator__default = /*#__PURE__*/_interopDefaultLegacy(Manipulator);\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.3): util/config.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n\n  /**\n   * Class definition\n   */\n\n\n  class Config {\n    // Getters\n    static get Default() {\n      return {};\n    }\n\n    static get DefaultType() {\n      return {};\n    }\n\n    static get NAME() {\n      throw new Error('You have to implement the static method \"NAME\", for each component!');\n    }\n\n    _getConfig(config) {\n      config = this._mergeConfigObj(config);\n      config = this._configAfterMerge(config);\n\n      this._typeCheckConfig(config);\n\n      return config;\n    }\n\n    _configAfterMerge(config) {\n      return config;\n    }\n\n    _mergeConfigObj(config, element) {\n      const jsonConfig = index.isElement(element) ? Manipulator__default.default.getDataAttribute(element, 'config') : {}; // try to parse\n\n      return { ...this.constructor.Default,\n        ...(typeof jsonConfig === 'object' ? jsonConfig : {}),\n        ...(index.isElement(element) ? Manipulator__default.default.getDataAttributes(element) : {}),\n        ...(typeof config === 'object' ? config : {})\n      };\n    }\n\n    _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {\n      for (const property of Object.keys(configTypes)) {\n        const expectedTypes = configTypes[property];\n        const value = config[property];\n        const valueType = index.isElement(value) ? 'element' : index.toType(value);\n\n        if (!new RegExp(expectedTypes).test(valueType)) {\n          throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option \"${property}\" provided type \"${valueType}\" but expected type \"${expectedTypes}\".`);\n        }\n      }\n    }\n\n  }\n\n  return Config;\n});","map":{"version":3,"sources":["../../src/util/config.js"],"names":["Default","DefaultType","NAME","_getConfig","config","_configAfterMerge","_mergeConfigObj","jsonConfig","isElement","Manipulator","_typeCheckConfig","configTypes","Object","expectedTypes","value","valueType","toType","property"],"mappings":";;;;;;;;;;;;;;;AAAA;;;;;;;AAUA;;;;;AAIA,QAAA,MAAA,CAAa;AACX;AACkB,eAAPA,OAAO,GAAG;AACnB,aAAA,EAAA;AACD;;AAEqB,eAAXC,WAAW,GAAG;AACvB,aAAA,EAAA;AACD;;AAEc,eAAJC,IAAI,GAAG;AAChB,YAAM,IAAA,KAAA,CAAN,qEAAM,CAAN;AACD;;AAEDC,IAAAA,UAAU,CAAA,MAAA,EAAS;AACjBC,MAAAA,MAAM,GAAG,KAAA,eAAA,CAATA,MAAS,CAATA;AACAA,MAAAA,MAAM,GAAG,KAAA,iBAAA,CAATA,MAAS,CAATA;;AACA,WAAA,gBAAA,CAAA,MAAA;;AACA,aAAA,MAAA;AACD;;AAEDC,IAAAA,iBAAiB,CAAA,MAAA,EAAS;AACxB,aAAA,MAAA;AACD;;AAEDC,IAAAA,eAAe,CAAA,MAAA,EAAA,OAAA,EAAkB;AAC/B,YAAMC,UAAU,GAAGC,KAAAA,CAAAA,SAAAA,CAAAA,OAAAA,IAAqBC,oBAAAA,CAAAA,OAAAA,CAAAA,gBAAAA,CAAAA,OAAAA,EAArBD,QAAqBC,CAArBD,GADY,EAC/B,CAD+B,CAAA;;AAG/B,aAAO,EACL,GAAG,KAAA,WAAA,CADE,OAAA;AAEL,YAAI,OAAA,UAAA,KAAA,QAAA,GAAA,UAAA,GAFC,EAEL,CAFK;AAGL,YAAIA,KAAAA,CAAAA,SAAAA,CAAAA,OAAAA,IAAqBC,oBAAAA,CAAAA,OAAAA,CAAAA,iBAAAA,CAArBD,OAAqBC,CAArBD,GAHC,EAGL,CAHK;AAIL,YAAI,OAAA,MAAA,KAAA,QAAA,GAAA,MAAA,GAAJ,EAAA;AAJK,OAAP;AAMD;;AAEDE,IAAAA,gBAAgB,CAAA,MAAA,EAASC,WAAW,GAAG,KAAA,WAAA,CAAvB,WAAA,EAAqD;AACnE,WAAK,MAAL,QAAA,IAAuBC,MAAM,CAANA,IAAAA,CAAvB,WAAuBA,CAAvB,EAAiD;AAC/C,cAAMC,aAAa,GAAGF,WAAW,CAAjC,QAAiC,CAAjC;AACA,cAAMG,KAAK,GAAGV,MAAM,CAApB,QAAoB,CAApB;AACA,cAAMW,SAAS,GAAGP,KAAAA,CAAAA,SAAAA,CAAAA,KAAAA,IAAAA,SAAAA,GAA+BQ,KAAAA,CAAAA,MAAAA,CAAjD,KAAiDA,CAAjD;;AAEA,YAAI,CAAC,IAAA,MAAA,CAAA,aAAA,EAAA,IAAA,CAAL,SAAK,CAAL,EAAgD;AAC9C,gBAAM,IAAA,SAAA,CACH,GAAE,KAAA,WAAA,CAAA,IAAA,CAAA,WAAA,EAAoC,aAAYC,QAAS,oBAAmBF,SAAiCF,wBAAAA,aADlH,IAAM,CAAN;AAGD;AACF;AACF;;AAhDU","sourcesContent":["/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.2.3): util/config.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nimport { isElement, toType } from './index'\nimport Manipulator from '../dom/manipulator'\n\n/**\n * Class definition\n */\n\nclass Config {\n  // Getters\n  static get Default() {\n    return {}\n  }\n\n  static get DefaultType() {\n    return {}\n  }\n\n  static get NAME() {\n    throw new Error('You have to implement the static method \"NAME\", for each component!')\n  }\n\n  _getConfig(config) {\n    config = this._mergeConfigObj(config)\n    config = this._configAfterMerge(config)\n    this._typeCheckConfig(config)\n    return config\n  }\n\n  _configAfterMerge(config) {\n    return config\n  }\n\n  _mergeConfigObj(config, element) {\n    const jsonConfig = isElement(element) ? Manipulator.getDataAttribute(element, 'config') : {} // try to parse\n\n    return {\n      ...this.constructor.Default,\n      ...(typeof jsonConfig === 'object' ? jsonConfig : {}),\n      ...(isElement(element) ? Manipulator.getDataAttributes(element) : {}),\n      ...(typeof config === 'object' ? config : {})\n    }\n  }\n\n  _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {\n    for (const property of Object.keys(configTypes)) {\n      const expectedTypes = configTypes[property]\n      const value = config[property]\n      const valueType = isElement(value) ? 'element' : toType(value)\n\n      if (!new RegExp(expectedTypes).test(valueType)) {\n        throw new TypeError(\n          `${this.constructor.NAME.toUpperCase()}: Option \"${property}\" provided type \"${valueType}\" but expected type \"${expectedTypes}\".`\n        )\n      }\n    }\n  }\n}\n\nexport default Config\n"]},"metadata":{},"sourceType":"script"}