{"ast":null,"code":"import { transformToViewState, applyViewStateToTransform, cloneTransform } from '../utils/transform';\nimport { normalizeStyle } from '../utils/style-utils';\nimport { deepEqual } from '../utils/deep-equal';\nconst pointerEvents = {\n  mousedown: 'onMouseDown',\n  mouseup: 'onMouseUp',\n  mouseover: 'onMouseOver',\n  mousemove: 'onMouseMove',\n  click: 'onClick',\n  dblclick: 'onDblClick',\n  mouseenter: 'onMouseEnter',\n  mouseleave: 'onMouseLeave',\n  mouseout: 'onMouseOut',\n  contextmenu: 'onContextMenu',\n  touchstart: 'onTouchStart',\n  touchend: 'onTouchEnd',\n  touchmove: 'onTouchMove',\n  touchcancel: 'onTouchCancel'\n};\nconst cameraEvents = {\n  movestart: 'onMoveStart',\n  move: 'onMove',\n  moveend: 'onMoveEnd',\n  dragstart: 'onDragStart',\n  drag: 'onDrag',\n  dragend: 'onDragEnd',\n  zoomstart: 'onZoomStart',\n  zoom: 'onZoom',\n  zoomend: 'onZoomEnd',\n  rotatestart: 'onRotateStart',\n  rotate: 'onRotate',\n  rotateend: 'onRotateEnd',\n  pitchstart: 'onPitchStart',\n  pitch: 'onPitch',\n  pitchend: 'onPitchEnd'\n};\nconst otherEvents = {\n  wheel: 'onWheel',\n  boxzoomstart: 'onBoxZoomStart',\n  boxzoomend: 'onBoxZoomEnd',\n  boxzoomcancel: 'onBoxZoomCancel',\n  resize: 'onResize',\n  load: 'onLoad',\n  render: 'onRender',\n  idle: 'onIdle',\n  remove: 'onRemove',\n  data: 'onData',\n  styledata: 'onStyleData',\n  sourcedata: 'onSourceData',\n  error: 'onError'\n};\nconst settingNames = ['minZoom', 'maxZoom', 'minPitch', 'maxPitch', 'maxBounds', 'projection', 'renderWorldCopies'];\nconst handlerNames = ['scrollZoom', 'boxZoom', 'dragRotate', 'dragPan', 'keyboard', 'doubleClickZoom', 'touchZoomRotate', 'touchPitch'];\n/**\n * A wrapper for mapbox-gl's Map class\n */\n\nexport default class Mapbox {\n  constructor(MapClass, props, container) {\n    // mapboxgl.Map instance. Not using type here because we are accessing\n    // private members and methods\n    this._map = null; // Internal states\n\n    this._internalUpdate = false;\n    this._inRender = false;\n    this._hoveredFeatures = null;\n    this._deferredEvents = {\n      move: false,\n      zoom: false,\n      pitch: false,\n      rotate: false\n    };\n\n    this._onEvent = e => {\n      // @ts-ignore\n      const cb = this.props[otherEvents[e.type]];\n\n      if (cb) {\n        cb(e);\n      }\n    };\n\n    this._onPointerEvent = e => {\n      if (e.type === 'mousemove' || e.type === 'mouseout') {\n        this._updateHover(e);\n      } // @ts-ignore\n\n\n      const cb = this.props[pointerEvents[e.type]];\n\n      if (cb) {\n        if (this.props.interactiveLayerIds && e.type !== 'mouseover' && e.type !== 'mouseout') {\n          const features = this._hoveredFeatures || this._map.queryRenderedFeatures(e.point, {\n            layers: this.props.interactiveLayerIds\n          });\n\n          e.features = features;\n        }\n\n        cb(e);\n        delete e.features;\n      }\n    };\n\n    this._onCameraEvent = e => {\n      if (!this._internalUpdate) {\n        // @ts-ignore\n        const cb = this.props[cameraEvents[e.type]];\n\n        if (cb) {\n          cb(e);\n        }\n      }\n\n      if (e.type in this._deferredEvents) {\n        this._deferredEvents[e.type] = false;\n      }\n    };\n\n    this._MapClass = MapClass;\n    this.props = props;\n\n    this._initialize(container);\n  }\n\n  get map() {\n    return this._map;\n  }\n\n  get transform() {\n    return this._renderTransform;\n  }\n\n  setProps(props) {\n    const oldProps = this.props;\n    this.props = props;\n\n    const settingsChanged = this._updateSettings(props, oldProps);\n\n    if (settingsChanged) {\n      this._createShadowTransform(this._map);\n    }\n\n    const sizeChanged = this._updateSize(props);\n\n    const viewStateChanged = this._updateViewState(props, true);\n\n    this._updateStyle(props, oldProps);\n\n    this._updateStyleComponents(props, oldProps);\n\n    this._updateHandlers(props, oldProps); // If 1) view state has changed to match props and\n    //    2) the props change is not triggered by map events,\n    // it's driven by an external state change. Redraw immediately\n\n\n    if (settingsChanged || sizeChanged || viewStateChanged && !this._map.isMoving()) {\n      this.redraw();\n    }\n  }\n\n  static reuse(props, container) {\n    const that = Mapbox.savedMaps.pop();\n\n    if (!that) {\n      return null;\n    }\n\n    const map = that.map; // When reusing the saved map, we need to reparent the map(canvas) and other child nodes\n    // intoto the new container from the props.\n    // Step1: reparenting child nodes from old container to new container\n\n    const oldContainer = map.getContainer();\n    container.className = oldContainer.className;\n\n    while (oldContainer.childNodes.length > 0) {\n      container.appendChild(oldContainer.childNodes[0]);\n    } // Step2: replace the internal container with new container from the react component\n    // @ts-ignore\n\n\n    map._container = container; // Step 3: apply new props\n\n    that.setProps({ ...props,\n      styleDiffing: false\n    });\n    map.resize();\n    const {\n      initialViewState\n    } = props;\n\n    if (initialViewState) {\n      if (initialViewState.bounds) {\n        map.fitBounds(initialViewState.bounds, { ...initialViewState.fitBoundsOptions,\n          duration: 0\n        });\n      } else {\n        that._updateViewState(initialViewState, false);\n      }\n    } // Simulate load event\n\n\n    if (map.isStyleLoaded()) {\n      map.fire('load');\n    } else {\n      map.once('styledata', () => map.fire('load'));\n    }\n\n    return that;\n  }\n  /* eslint-disable complexity,max-statements */\n\n\n  _initialize(container) {\n    const {\n      props\n    } = this;\n    const mapOptions = { ...props,\n      ...props.initialViewState,\n      accessToken: props.mapboxAccessToken || getAccessTokenFromEnv() || null,\n      container,\n      style: normalizeStyle(props.mapStyle)\n    };\n    const viewState = mapOptions.initialViewState || mapOptions.viewState || mapOptions;\n    Object.assign(mapOptions, {\n      center: [viewState.longitude || 0, viewState.latitude || 0],\n      zoom: viewState.zoom || 0,\n      pitch: viewState.pitch || 0,\n      bearing: viewState.bearing || 0\n    });\n\n    if (props.gl) {\n      // eslint-disable-next-line\n      const getContext = HTMLCanvasElement.prototype.getContext; // Hijack canvas.getContext to return our own WebGLContext\n      // This will be called inside the mapboxgl.Map constructor\n      // @ts-expect-error\n\n      HTMLCanvasElement.prototype.getContext = () => {\n        // Unhijack immediately\n        HTMLCanvasElement.prototype.getContext = getContext;\n        return props.gl;\n      };\n    }\n\n    const map = new this._MapClass(mapOptions); // Props that are not part of constructor options\n\n    if (viewState.padding) {\n      map.setPadding(viewState.padding);\n    }\n\n    if (props.cursor) {\n      map.getCanvas().style.cursor = props.cursor;\n    }\n\n    this._createShadowTransform(map); // Hack\n    // Insert code into map's render cycle\n\n\n    const renderMap = map._render;\n\n    map._render = arg => {\n      this._inRender = true;\n      renderMap.call(map, arg);\n      this._inRender = false;\n    };\n\n    const runRenderTaskQueue = map._renderTaskQueue.run;\n\n    map._renderTaskQueue.run = arg => {\n      runRenderTaskQueue.call(map._renderTaskQueue, arg);\n\n      this._onBeforeRepaint();\n    };\n\n    map.on('render', () => this._onAfterRepaint()); // Insert code into map's event pipeline\n\n    const fireEvent = map.fire;\n    map.fire = this._fireEvent.bind(this, fireEvent); // add listeners\n\n    map.on('resize', () => {\n      this._renderTransform.resize(map.transform.width, map.transform.height);\n    });\n    map.on('styledata', () => this._updateStyleComponents(this.props, {}));\n    map.on('sourcedata', () => this._updateStyleComponents(this.props, {}));\n\n    for (const eventName in pointerEvents) {\n      map.on(eventName, this._onPointerEvent);\n    }\n\n    for (const eventName in cameraEvents) {\n      map.on(eventName, this._onCameraEvent);\n    }\n\n    for (const eventName in otherEvents) {\n      map.on(eventName, this._onEvent);\n    }\n\n    this._map = map;\n  }\n  /* eslint-enable complexity,max-statements */\n\n\n  recycle() {\n    // Clean up unnecessary elements before storing for reuse.\n    const container = this.map.getContainer();\n    const children = container.querySelector('[mapboxgl-children]');\n    children === null || children === void 0 ? void 0 : children.remove();\n    Mapbox.savedMaps.push(this);\n  }\n\n  destroy() {\n    this._map.remove();\n  } // Force redraw the map now. Typically resize() and jumpTo() is reflected in the next\n  // render cycle, which is managed by Mapbox's animation loop.\n  // This removes the synchronization issue caused by requestAnimationFrame.\n\n\n  redraw() {\n    const map = this._map; // map._render will throw error if style does not exist\n    // https://github.com/mapbox/mapbox-gl-js/blob/fb9fc316da14e99ff4368f3e4faa3888fb43c513\n    //   /src/ui/map.js#L1834\n\n    if (!this._inRender && map.style) {\n      // cancel the scheduled update\n      if (map._frame) {\n        map._frame.cancel();\n\n        map._frame = null;\n      } // the order is important - render() may schedule another update\n\n\n      map._render();\n    }\n  }\n\n  _createShadowTransform(map) {\n    const renderTransform = cloneTransform(map.transform);\n    map.painter.transform = renderTransform;\n    this._renderTransform = renderTransform;\n  }\n  /* Trigger map resize if size is controlled\n     @param {object} nextProps\n     @returns {bool} true if size has changed\n   */\n\n\n  _updateSize(nextProps) {\n    // Check if size is controlled\n    const {\n      viewState\n    } = nextProps;\n\n    if (viewState) {\n      const map = this._map;\n\n      if (viewState.width !== map.transform.width || viewState.height !== map.transform.height) {\n        map.resize();\n        return true;\n      }\n    }\n\n    return false;\n  } // Adapted from map.jumpTo\n\n  /* Update camera to match props\n     @param {object} nextProps\n     @param {bool} triggerEvents - should fire camera events\n     @returns {bool} true if anything is changed\n   */\n\n\n  _updateViewState(nextProps, triggerEvents) {\n    if (this._internalUpdate) {\n      return false;\n    }\n\n    const map = this._map;\n    const tr = this._renderTransform; // Take a snapshot of the transform before mutation\n\n    const {\n      zoom,\n      pitch,\n      bearing\n    } = tr;\n    const isMoving = map.isMoving();\n\n    if (isMoving) {\n      // All movement of the camera is done relative to the sea level\n      tr.cameraElevationReference = 'sea';\n    }\n\n    const changed = applyViewStateToTransform(tr, { ...transformToViewState(map.transform),\n      ...nextProps\n    });\n\n    if (isMoving) {\n      // Reset camera reference\n      tr.cameraElevationReference = 'ground';\n    }\n\n    if (changed && triggerEvents) {\n      const deferredEvents = this._deferredEvents; // Delay DOM control updates to the next render cycle\n\n      deferredEvents.move = true;\n      deferredEvents.zoom || (deferredEvents.zoom = zoom !== tr.zoom);\n      deferredEvents.rotate || (deferredEvents.rotate = bearing !== tr.bearing);\n      deferredEvents.pitch || (deferredEvents.pitch = pitch !== tr.pitch);\n    } // Avoid manipulating the real transform when interaction/animation is ongoing\n    // as it would interfere with Mapbox's handlers\n\n\n    if (!isMoving) {\n      applyViewStateToTransform(map.transform, nextProps);\n    }\n\n    return changed;\n  }\n  /* Update camera constraints and projection settings to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if anything is changed\n   */\n\n\n  _updateSettings(nextProps, currProps) {\n    const map = this._map;\n    let changed = false;\n\n    for (const propName of settingNames) {\n      if (propName in nextProps && !deepEqual(nextProps[propName], currProps[propName])) {\n        changed = true;\n        map[`set${propName[0].toUpperCase()}${propName.slice(1)}`](nextProps[propName]);\n      }\n    }\n\n    return changed;\n  }\n  /* Update map style to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if style is changed\n   */\n\n\n  _updateStyle(nextProps, currProps) {\n    if (nextProps.cursor !== currProps.cursor) {\n      this._map.getCanvas().style.cursor = nextProps.cursor;\n    }\n\n    if (nextProps.mapStyle !== currProps.mapStyle) {\n      const options = {\n        diff: nextProps.styleDiffing\n      };\n\n      if ('localIdeographFontFamily' in nextProps) {\n        options.localIdeographFontFamily = nextProps.localIdeographFontFamily;\n      }\n\n      this._map.setStyle(normalizeStyle(nextProps.mapStyle), options);\n\n      return true;\n    }\n\n    return false;\n  }\n  /* Update fog, light and terrain to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if anything is changed\n   */\n\n\n  _updateStyleComponents(nextProps, currProps) {\n    const map = this._map;\n    let changed = false;\n\n    if (map.style.loaded()) {\n      if ('light' in nextProps && !deepEqual(nextProps.light, currProps.light)) {\n        changed = true;\n        map.setLight(nextProps.light);\n      }\n\n      if ('fog' in nextProps && !deepEqual(nextProps.fog, currProps.fog)) {\n        changed = true;\n        map.setFog(nextProps.fog);\n      }\n\n      if ('terrain' in nextProps && !deepEqual(nextProps.terrain, currProps.terrain)) {\n        if (!nextProps.terrain || map.getSource(nextProps.terrain.source)) {\n          changed = true;\n          map.setTerrain(nextProps.terrain);\n        }\n      }\n    }\n\n    return changed;\n  }\n  /* Update interaction handlers to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if anything is changed\n   */\n\n\n  _updateHandlers(nextProps, currProps) {\n    const map = this._map;\n    let changed = false;\n\n    for (const propName of handlerNames) {\n      const newValue = nextProps[propName];\n\n      if (!deepEqual(newValue, currProps[propName])) {\n        changed = true;\n\n        if (newValue) {\n          map[propName].enable(newValue);\n        } else {\n          map[propName].disable();\n        }\n      }\n    }\n\n    return changed;\n  }\n\n  _updateHover(e) {\n    var _a;\n\n    const {\n      props\n    } = this;\n    const shouldTrackHoveredFeatures = props.interactiveLayerIds && (props.onMouseMove || props.onMouseEnter || props.onMouseLeave);\n\n    if (shouldTrackHoveredFeatures) {\n      const eventType = e.type;\n      const wasHovering = ((_a = this._hoveredFeatures) === null || _a === void 0 ? void 0 : _a.length) > 0;\n      let features;\n\n      if (eventType === 'mousemove') {\n        try {\n          features = this._map.queryRenderedFeatures(e.point, {\n            layers: props.interactiveLayerIds\n          });\n        } catch (_b) {\n          features = [];\n        }\n      } else {\n        features = [];\n      }\n\n      const isHovering = features.length > 0;\n\n      if (!isHovering && wasHovering) {\n        e.type = 'mouseleave';\n\n        this._onPointerEvent(e);\n      }\n\n      this._hoveredFeatures = features;\n\n      if (isHovering && !wasHovering) {\n        e.type = 'mouseenter';\n\n        this._onPointerEvent(e);\n      }\n\n      e.type = eventType;\n    } else {\n      this._hoveredFeatures = null;\n    }\n  }\n\n  _fireEvent(baseFire, event, properties) {\n    const map = this._map;\n    const tr = map.transform;\n    const eventType = typeof event === 'string' ? event : event.type;\n\n    if (eventType === 'move') {\n      this._updateViewState(this.props, false);\n    }\n\n    if (eventType in cameraEvents) {\n      if (typeof event === 'object') {\n        event.viewState = transformToViewState(tr);\n      }\n\n      if (this._map.isMoving()) {\n        // Replace map.transform with ours during the callbacks\n        map.transform = this._renderTransform;\n        baseFire.call(map, event, properties);\n        map.transform = tr;\n        return map;\n      }\n    }\n\n    baseFire.call(map, event, properties);\n    return map;\n  } // All camera manipulations are complete, ready to repaint\n\n\n  _onBeforeRepaint() {\n    const map = this._map; // If there are camera changes driven by props, invoke camera events so that DOM controls are synced\n\n    this._internalUpdate = true;\n\n    for (const eventType in this._deferredEvents) {\n      if (this._deferredEvents[eventType]) {\n        map.fire(eventType);\n      }\n    }\n\n    this._internalUpdate = false;\n    const tr = this._map.transform; // Make sure camera matches the current props\n\n    this._map.transform = this._renderTransform;\n\n    this._onAfterRepaint = () => {\n      // Restores camera state before render/load events are fired\n      this._map.transform = tr;\n    };\n  }\n\n}\nMapbox.savedMaps = [];\n/**\n * Access token can be provided via one of:\n *   mapboxAccessToken prop\n *   access_token query parameter\n *   MapboxAccessToken environment variable\n *   REACT_APP_MAPBOX_ACCESS_TOKEN environment variable\n * @returns access token\n */\n\nfunction getAccessTokenFromEnv() {\n  let accessToken = null;\n  /* global location, process */\n\n  if (typeof location !== 'undefined') {\n    const match = /access_token=([^&\\/]*)/.exec(location.search);\n    accessToken = match && match[1];\n  } // Note: This depends on bundler plugins (e.g. webpack) importing environment correctly\n\n\n  try {\n    accessToken = accessToken || process.env.MapboxAccessToken;\n  } catch (_a) {// ignore\n  }\n\n  try {\n    accessToken = accessToken || process.env.REACT_APP_MAPBOX_ACCESS_TOKEN;\n  } catch (_b) {// ignore\n  }\n\n  return accessToken;\n}","map":{"version":3,"sources":["../../../src/mapbox/mapbox.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { transformToViewState, applyViewStateToTransform, cloneTransform } from '../utils/transform';\nimport { normalizeStyle } from '../utils/style-utils';\nimport { deepEqual } from '../utils/deep-equal';\nconst pointerEvents = {\n    mousedown: 'onMouseDown',\n    mouseup: 'onMouseUp',\n    mouseover: 'onMouseOver',\n    mousemove: 'onMouseMove',\n    click: 'onClick',\n    dblclick: 'onDblClick',\n    mouseenter: 'onMouseEnter',\n    mouseleave: 'onMouseLeave',\n    mouseout: 'onMouseOut',\n    contextmenu: 'onContextMenu',\n    touchstart: 'onTouchStart',\n    touchend: 'onTouchEnd',\n    touchmove: 'onTouchMove',\n    touchcancel: 'onTouchCancel'\n};\nconst cameraEvents = {\n    movestart: 'onMoveStart',\n    move: 'onMove',\n    moveend: 'onMoveEnd',\n    dragstart: 'onDragStart',\n    drag: 'onDrag',\n    dragend: 'onDragEnd',\n    zoomstart: 'onZoomStart',\n    zoom: 'onZoom',\n    zoomend: 'onZoomEnd',\n    rotatestart: 'onRotateStart',\n    rotate: 'onRotate',\n    rotateend: 'onRotateEnd',\n    pitchstart: 'onPitchStart',\n    pitch: 'onPitch',\n    pitchend: 'onPitchEnd'\n};\nconst otherEvents = {\n    wheel: 'onWheel',\n    boxzoomstart: 'onBoxZoomStart',\n    boxzoomend: 'onBoxZoomEnd',\n    boxzoomcancel: 'onBoxZoomCancel',\n    resize: 'onResize',\n    load: 'onLoad',\n    render: 'onRender',\n    idle: 'onIdle',\n    remove: 'onRemove',\n    data: 'onData',\n    styledata: 'onStyleData',\n    sourcedata: 'onSourceData',\n    error: 'onError'\n};\nconst settingNames = [\n    'minZoom',\n    'maxZoom',\n    'minPitch',\n    'maxPitch',\n    'maxBounds',\n    'projection',\n    'renderWorldCopies'\n];\nconst handlerNames = [\n    'scrollZoom',\n    'boxZoom',\n    'dragRotate',\n    'dragPan',\n    'keyboard',\n    'doubleClickZoom',\n    'touchZoomRotate',\n    'touchPitch'\n];\n/**\n * A wrapper for mapbox-gl's Map class\n */\nexport default class Mapbox {\n    constructor(MapClass, props, container) {\n        // mapboxgl.Map instance. Not using type here because we are accessing\n        // private members and methods\n        this._map = null;\n        // Internal states\n        this._internalUpdate = false;\n        this._inRender = false;\n        this._hoveredFeatures = null;\n        this._deferredEvents = {\n            move: false,\n            zoom: false,\n            pitch: false,\n            rotate: false\n        };\n        this._onEvent = (e) => {\n            // @ts-ignore\n            const cb = this.props[otherEvents[e.type]];\n            if (cb) {\n                cb(e);\n            }\n        };\n        this._onPointerEvent = (e) => {\n            if (e.type === 'mousemove' || e.type === 'mouseout') {\n                this._updateHover(e);\n            }\n            // @ts-ignore\n            const cb = this.props[pointerEvents[e.type]];\n            if (cb) {\n                if (this.props.interactiveLayerIds && e.type !== 'mouseover' && e.type !== 'mouseout') {\n                    const features = this._hoveredFeatures ||\n                        this._map.queryRenderedFeatures(e.point, {\n                            layers: this.props.interactiveLayerIds\n                        });\n                    e.features = features;\n                }\n                cb(e);\n                delete e.features;\n            }\n        };\n        this._onCameraEvent = (e) => {\n            if (!this._internalUpdate) {\n                // @ts-ignore\n                const cb = this.props[cameraEvents[e.type]];\n                if (cb) {\n                    cb(e);\n                }\n            }\n            if (e.type in this._deferredEvents) {\n                this._deferredEvents[e.type] = false;\n            }\n        };\n        this._MapClass = MapClass;\n        this.props = props;\n        this._initialize(container);\n    }\n    get map() {\n        return this._map;\n    }\n    get transform() {\n        return this._renderTransform;\n    }\n    setProps(props) {\n        const oldProps = this.props;\n        this.props = props;\n        const settingsChanged = this._updateSettings(props, oldProps);\n        if (settingsChanged) {\n            this._createShadowTransform(this._map);\n        }\n        const sizeChanged = this._updateSize(props);\n        const viewStateChanged = this._updateViewState(props, true);\n        this._updateStyle(props, oldProps);\n        this._updateStyleComponents(props, oldProps);\n        this._updateHandlers(props, oldProps);\n        // If 1) view state has changed to match props and\n        //    2) the props change is not triggered by map events,\n        // it's driven by an external state change. Redraw immediately\n        if (settingsChanged || sizeChanged || (viewStateChanged && !this._map.isMoving())) {\n            this.redraw();\n        }\n    }\n    static reuse(props, container) {\n        const that = Mapbox.savedMaps.pop();\n        if (!that) {\n            return null;\n        }\n        const map = that.map;\n        // When reusing the saved map, we need to reparent the map(canvas) and other child nodes\n        // intoto the new container from the props.\n        // Step1: reparenting child nodes from old container to new container\n        const oldContainer = map.getContainer();\n        container.className = oldContainer.className;\n        while (oldContainer.childNodes.length > 0) {\n            container.appendChild(oldContainer.childNodes[0]);\n        }\n        // Step2: replace the internal container with new container from the react component\n        // @ts-ignore\n        map._container = container;\n        // Step 3: apply new props\n        that.setProps({ ...props, styleDiffing: false });\n        map.resize();\n        const { initialViewState } = props;\n        if (initialViewState) {\n            if (initialViewState.bounds) {\n                map.fitBounds(initialViewState.bounds, { ...initialViewState.fitBoundsOptions, duration: 0 });\n            }\n            else {\n                that._updateViewState(initialViewState, false);\n            }\n        }\n        // Simulate load event\n        if (map.isStyleLoaded()) {\n            map.fire('load');\n        }\n        else {\n            map.once('styledata', () => map.fire('load'));\n        }\n        return that;\n    }\n    /* eslint-disable complexity,max-statements */\n    _initialize(container) {\n        const { props } = this;\n        const mapOptions = {\n            ...props,\n            ...props.initialViewState,\n            accessToken: props.mapboxAccessToken || getAccessTokenFromEnv() || null,\n            container,\n            style: normalizeStyle(props.mapStyle)\n        };\n        const viewState = mapOptions.initialViewState || mapOptions.viewState || mapOptions;\n        Object.assign(mapOptions, {\n            center: [viewState.longitude || 0, viewState.latitude || 0],\n            zoom: viewState.zoom || 0,\n            pitch: viewState.pitch || 0,\n            bearing: viewState.bearing || 0\n        });\n        if (props.gl) {\n            // eslint-disable-next-line\n            const getContext = HTMLCanvasElement.prototype.getContext;\n            // Hijack canvas.getContext to return our own WebGLContext\n            // This will be called inside the mapboxgl.Map constructor\n            // @ts-expect-error\n            HTMLCanvasElement.prototype.getContext = () => {\n                // Unhijack immediately\n                HTMLCanvasElement.prototype.getContext = getContext;\n                return props.gl;\n            };\n        }\n        const map = new this._MapClass(mapOptions);\n        // Props that are not part of constructor options\n        if (viewState.padding) {\n            map.setPadding(viewState.padding);\n        }\n        if (props.cursor) {\n            map.getCanvas().style.cursor = props.cursor;\n        }\n        this._createShadowTransform(map);\n        // Hack\n        // Insert code into map's render cycle\n        const renderMap = map._render;\n        map._render = (arg) => {\n            this._inRender = true;\n            renderMap.call(map, arg);\n            this._inRender = false;\n        };\n        const runRenderTaskQueue = map._renderTaskQueue.run;\n        map._renderTaskQueue.run = (arg) => {\n            runRenderTaskQueue.call(map._renderTaskQueue, arg);\n            this._onBeforeRepaint();\n        };\n        map.on('render', () => this._onAfterRepaint());\n        // Insert code into map's event pipeline\n        const fireEvent = map.fire;\n        map.fire = this._fireEvent.bind(this, fireEvent);\n        // add listeners\n        map.on('resize', () => {\n            this._renderTransform.resize(map.transform.width, map.transform.height);\n        });\n        map.on('styledata', () => this._updateStyleComponents(this.props, {}));\n        map.on('sourcedata', () => this._updateStyleComponents(this.props, {}));\n        for (const eventName in pointerEvents) {\n            map.on(eventName, this._onPointerEvent);\n        }\n        for (const eventName in cameraEvents) {\n            map.on(eventName, this._onCameraEvent);\n        }\n        for (const eventName in otherEvents) {\n            map.on(eventName, this._onEvent);\n        }\n        this._map = map;\n    }\n    /* eslint-enable complexity,max-statements */\n    recycle() {\n        // Clean up unnecessary elements before storing for reuse.\n        const container = this.map.getContainer();\n        const children = container.querySelector('[mapboxgl-children]');\n        children === null || children === void 0 ? void 0 : children.remove();\n        Mapbox.savedMaps.push(this);\n    }\n    destroy() {\n        this._map.remove();\n    }\n    // Force redraw the map now. Typically resize() and jumpTo() is reflected in the next\n    // render cycle, which is managed by Mapbox's animation loop.\n    // This removes the synchronization issue caused by requestAnimationFrame.\n    redraw() {\n        const map = this._map;\n        // map._render will throw error if style does not exist\n        // https://github.com/mapbox/mapbox-gl-js/blob/fb9fc316da14e99ff4368f3e4faa3888fb43c513\n        //   /src/ui/map.js#L1834\n        if (!this._inRender && map.style) {\n            // cancel the scheduled update\n            if (map._frame) {\n                map._frame.cancel();\n                map._frame = null;\n            }\n            // the order is important - render() may schedule another update\n            map._render();\n        }\n    }\n    _createShadowTransform(map) {\n        const renderTransform = cloneTransform(map.transform);\n        map.painter.transform = renderTransform;\n        this._renderTransform = renderTransform;\n    }\n    /* Trigger map resize if size is controlled\n       @param {object} nextProps\n       @returns {bool} true if size has changed\n     */\n    _updateSize(nextProps) {\n        // Check if size is controlled\n        const { viewState } = nextProps;\n        if (viewState) {\n            const map = this._map;\n            if (viewState.width !== map.transform.width || viewState.height !== map.transform.height) {\n                map.resize();\n                return true;\n            }\n        }\n        return false;\n    }\n    // Adapted from map.jumpTo\n    /* Update camera to match props\n       @param {object} nextProps\n       @param {bool} triggerEvents - should fire camera events\n       @returns {bool} true if anything is changed\n     */\n    _updateViewState(nextProps, triggerEvents) {\n        if (this._internalUpdate) {\n            return false;\n        }\n        const map = this._map;\n        const tr = this._renderTransform;\n        // Take a snapshot of the transform before mutation\n        const { zoom, pitch, bearing } = tr;\n        const isMoving = map.isMoving();\n        if (isMoving) {\n            // All movement of the camera is done relative to the sea level\n            tr.cameraElevationReference = 'sea';\n        }\n        const changed = applyViewStateToTransform(tr, {\n            ...transformToViewState(map.transform),\n            ...nextProps\n        });\n        if (isMoving) {\n            // Reset camera reference\n            tr.cameraElevationReference = 'ground';\n        }\n        if (changed && triggerEvents) {\n            const deferredEvents = this._deferredEvents;\n            // Delay DOM control updates to the next render cycle\n            deferredEvents.move = true;\n            deferredEvents.zoom || (deferredEvents.zoom = zoom !== tr.zoom);\n            deferredEvents.rotate || (deferredEvents.rotate = bearing !== tr.bearing);\n            deferredEvents.pitch || (deferredEvents.pitch = pitch !== tr.pitch);\n        }\n        // Avoid manipulating the real transform when interaction/animation is ongoing\n        // as it would interfere with Mapbox's handlers\n        if (!isMoving) {\n            applyViewStateToTransform(map.transform, nextProps);\n        }\n        return changed;\n    }\n    /* Update camera constraints and projection settings to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if anything is changed\n     */\n    _updateSettings(nextProps, currProps) {\n        const map = this._map;\n        let changed = false;\n        for (const propName of settingNames) {\n            if (propName in nextProps && !deepEqual(nextProps[propName], currProps[propName])) {\n                changed = true;\n                map[`set${propName[0].toUpperCase()}${propName.slice(1)}`](nextProps[propName]);\n            }\n        }\n        return changed;\n    }\n    /* Update map style to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if style is changed\n     */\n    _updateStyle(nextProps, currProps) {\n        if (nextProps.cursor !== currProps.cursor) {\n            this._map.getCanvas().style.cursor = nextProps.cursor;\n        }\n        if (nextProps.mapStyle !== currProps.mapStyle) {\n            const options = {\n                diff: nextProps.styleDiffing\n            };\n            if ('localIdeographFontFamily' in nextProps) {\n                options.localIdeographFontFamily = nextProps.localIdeographFontFamily;\n            }\n            this._map.setStyle(normalizeStyle(nextProps.mapStyle), options);\n            return true;\n        }\n        return false;\n    }\n    /* Update fog, light and terrain to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if anything is changed\n     */\n    _updateStyleComponents(nextProps, currProps) {\n        const map = this._map;\n        let changed = false;\n        if (map.style.loaded()) {\n            if ('light' in nextProps && !deepEqual(nextProps.light, currProps.light)) {\n                changed = true;\n                map.setLight(nextProps.light);\n            }\n            if ('fog' in nextProps && !deepEqual(nextProps.fog, currProps.fog)) {\n                changed = true;\n                map.setFog(nextProps.fog);\n            }\n            if ('terrain' in nextProps && !deepEqual(nextProps.terrain, currProps.terrain)) {\n                if (!nextProps.terrain || map.getSource(nextProps.terrain.source)) {\n                    changed = true;\n                    map.setTerrain(nextProps.terrain);\n                }\n            }\n        }\n        return changed;\n    }\n    /* Update interaction handlers to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if anything is changed\n     */\n    _updateHandlers(nextProps, currProps) {\n        const map = this._map;\n        let changed = false;\n        for (const propName of handlerNames) {\n            const newValue = nextProps[propName];\n            if (!deepEqual(newValue, currProps[propName])) {\n                changed = true;\n                if (newValue) {\n                    map[propName].enable(newValue);\n                }\n                else {\n                    map[propName].disable();\n                }\n            }\n        }\n        return changed;\n    }\n    _updateHover(e) {\n        var _a;\n        const { props } = this;\n        const shouldTrackHoveredFeatures = props.interactiveLayerIds && (props.onMouseMove || props.onMouseEnter || props.onMouseLeave);\n        if (shouldTrackHoveredFeatures) {\n            const eventType = e.type;\n            const wasHovering = ((_a = this._hoveredFeatures) === null || _a === void 0 ? void 0 : _a.length) > 0;\n            let features;\n            if (eventType === 'mousemove') {\n                try {\n                    features = this._map.queryRenderedFeatures(e.point, {\n                        layers: props.interactiveLayerIds\n                    });\n                }\n                catch (_b) {\n                    features = [];\n                }\n            }\n            else {\n                features = [];\n            }\n            const isHovering = features.length > 0;\n            if (!isHovering && wasHovering) {\n                e.type = 'mouseleave';\n                this._onPointerEvent(e);\n            }\n            this._hoveredFeatures = features;\n            if (isHovering && !wasHovering) {\n                e.type = 'mouseenter';\n                this._onPointerEvent(e);\n            }\n            e.type = eventType;\n        }\n        else {\n            this._hoveredFeatures = null;\n        }\n    }\n    _fireEvent(baseFire, event, properties) {\n        const map = this._map;\n        const tr = map.transform;\n        const eventType = typeof event === 'string' ? event : event.type;\n        if (eventType === 'move') {\n            this._updateViewState(this.props, false);\n        }\n        if (eventType in cameraEvents) {\n            if (typeof event === 'object') {\n                event.viewState = transformToViewState(tr);\n            }\n            if (this._map.isMoving()) {\n                // Replace map.transform with ours during the callbacks\n                map.transform = this._renderTransform;\n                baseFire.call(map, event, properties);\n                map.transform = tr;\n                return map;\n            }\n        }\n        baseFire.call(map, event, properties);\n        return map;\n    }\n    // All camera manipulations are complete, ready to repaint\n    _onBeforeRepaint() {\n        const map = this._map;\n        // If there are camera changes driven by props, invoke camera events so that DOM controls are synced\n        this._internalUpdate = true;\n        for (const eventType in this._deferredEvents) {\n            if (this._deferredEvents[eventType]) {\n                map.fire(eventType);\n            }\n        }\n        this._internalUpdate = false;\n        const tr = this._map.transform;\n        // Make sure camera matches the current props\n        this._map.transform = this._renderTransform;\n        this._onAfterRepaint = () => {\n            // Restores camera state before render/load events are fired\n            this._map.transform = tr;\n        };\n    }\n}\nMapbox.savedMaps = [];\n/**\n * Access token can be provided via one of:\n *   mapboxAccessToken prop\n *   access_token query parameter\n *   MapboxAccessToken environment variable\n *   REACT_APP_MAPBOX_ACCESS_TOKEN environment variable\n * @returns access token\n */\nfunction getAccessTokenFromEnv() {\n    let accessToken = null;\n    /* global location, process */\n    if (typeof location !== 'undefined') {\n        const match = /access_token=([^&\\/]*)/.exec(location.search);\n        accessToken = match && match[1];\n    }\n    // Note: This depends on bundler plugins (e.g. webpack) importing environment correctly\n    try {\n        accessToken = accessToken || process.env.MapboxAccessToken;\n    }\n    catch (_a) {\n        // ignore\n    }\n    try {\n        accessToken = accessToken || process.env.REACT_APP_MAPBOX_ACCESS_TOKEN;\n    }\n    catch (_b) {\n        // ignore\n    }\n    return accessToken;\n}\n//# sourceMappingURL=mapbox.js.map"]},"metadata":{},"sourceType":"module"}